System Call Table
---------------------

The system call table is represented by the sys_call_table array

Defined: arch/x86/entry/syscall_64.c

asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = {
        /*
         * Smells like a compiler bug -- it doesn't work
         * when the & below is removed.
         */
        [0 ... __NR_syscall_max] = &sys_ni_syscall,
#include <asm/syscalls_64.h>
};

You can see, sys_call_table is an array of __NR_syscall_max + 1 size 

__NR_syscall_max macro represents the maximum number of system calls for the given architecture

this macro in the header file generated by Kbuild during kernel compilation

on x86_64

./include/generated/asm-offsets.h:43:#define __NR_syscall_max 547 /* sizeof(syscalls_64) - 1 */

sys_call_ptr_t -->  typedef asmlinkage long (*sys_call_ptr_t)(const struct pt_regs *);

Initialization of sys_call_table
--------------------------------

all elements of array that contain pointers to the system call handlers point to the sys_ni_syscall

The sys_ni_syscall function represents not-implemented system calls

Implementation of the sys_ni_syscall is pretty easy, it just returns -errno or -ENOSYS in our case

 To start with, all elements of the sys_call_table array point to the not-implemented system call

...	-->	a GCC compiler extension called - Designated Initializers allows us to initialize elements in non-fixed order

we included the asm/syscalls_64.h header at the end of the array

This header file is generated by the special script at arch/x86/entry/syscalls/syscalltbl.sh and generates our header file from the syscall table.

./arch/x86/include/generated/asm/syscalls_64.h
./arch/x86/include/generated/asm/syscalls_32.h

